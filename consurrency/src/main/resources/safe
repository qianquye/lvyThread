线程安全性：
1、原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作
2、可见性：一个线程对主内存的修改可以及时的被其他线程观察到
3、有序性：一个线程观察其他线程中的指令执行顺序。由于指令重排序的存在，该观察结果一般杂乱无序

原子性 - Atomic包
1、AtomicXXX: CAS、Unsafe.compareAndSwapInt
2、AtomicLong、LongAdder
3、AtomicReference、atomicReferenceFieldUpdater
4、AtomicStampReference: CAS的ABA问题

原子性 - synchronized
1、修饰代码块：大括号括起来的代码，作用于调用的对象
2、修饰方法：整个方法，作用于调用的对象
3、修饰静态方法：整个静态方法，作用于所有对象
4、修饰类：括号括起来的部分，作用于所有对象

原子性的对比
synchronized: 不可中断锁，适合竟争不激烈，可读性好
Lock : 可中断锁，多样化同步，竟争激烈时能维持常态
Atomic: 竟争激烈时能维持常态，比lock性能好，缺点只能同步一个值

可见性（synchronized，volatile）
导致共享变量在线程间不可见的原因：
1、线程交叉执行
2、重排序结合线程 交叉执行、
3、共享变量更新后的值没有在工作内存与主存间及时更新

有序性
java 内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程 不会影响到单线程的执行，却
会影响到多线程并发执行的正确性
happen-before原则（如果一个程序没法从happen-before原则中推倒出，就会出现重排序）

发布对象
发布对象：使一个对象能够被当前范围外的代码所有用
对象逸出：一种错误的发布，当一个对象还没有构造完成时，就使它被其他线程所见。

安全发布对象
1、在静态初始化函数中初始化一个对象的引用
2、将对象的引用保存到volatile类型域或者atomicReference对象中
3、将对象的引用保存到某个正确构造对象的final类型域中
4、将对象的引用保存到一个由锁保护的域中